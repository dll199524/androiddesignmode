

import org.aspectj.bridge.IMessage
import org.aspectj.bridge.MessageHandler
import org.aspectj.tools.ajc.Main
import org.apache.commons.compress.utils.IOUtils
import org.objectweb.asm.*


import java.util.jar.JarEntry
import java.util.jar.JarFile
import java.util.jar.JarOutputStream


plugins {
    id 'com.android.application'
}

//def app_android = this.getRootProject().ext.app_android
//def app_dependences = this.getRootProject().ext.app_dependences

android {
    compileSdk app_android.compileSdk

    defaultConfig {
        applicationId "com.example.designmode"
        minSdk app_android.minSdk
        targetSdk app_android.targetSdk
        versionCode app_android.versionCode
        versionName app_android.versionName

        testInstrumentationRunner app_android.testInstrumentationRunner
    }

    buildTypes {
        release {
            minifyEnabled false
            proguardFiles getDefaultProguardFile('proguard-android-optimize.txt'), 'proguard-rules.pro'
        }
    }
    compileOptions {
        sourceCompatibility JavaVersion.VERSION_1_8
        targetCompatibility JavaVersion.VERSION_1_8
    }
}

dependencies {

    implementation 'androidx.appcompat:appcompat:1.3.0'
    implementation 'com.google.android.material:material:1.4.0'
    implementation 'androidx.constraintlayout:constraintlayout:2.0.4'
    implementation "androidx.asynclayoutinflater:asynclayoutinflater:1.0.0"

    app_dependences.each { k, v -> implementation v}

}


final def log = project.logger
final def variants = project.android.applicationVariants

variants.all { variant ->
    if (!variant.buildType.isDebuggable()) {
        log.debug("Skipping non-debuggable build type '${variant.buildType.name}'.")
        return;
    }

    JavaCompile javaCompile = variant.javaCompile
    javaCompile.doLast {
        String[] args = ["-showWeaveInfo",
                         "-1.8",
                         "-inpath", javaCompile.destinationDir.toString(),
                         "-aspectpath", javaCompile.classpath.asPath,
                         "-d", javaCompile.destinationDir.toString(),
                         "-classpath", javaCompile.classpath.asPath,
                         "-bootclasspath", project.android.bootClasspath.join(File.pathSeparator)]
        log.debug "ajc args: " + Arrays.toString(args)

        MessageHandler handler = new MessageHandler(true);
        new Main().run(args, handler);
        for (IMessage message : handler.getMessages(null, true)) {
            switch (message.getKind()) {
                case IMessage.ABORT:
                case IMessage.ERROR:
                case IMessage.FAIL:
                    log.error message.message, message.thrown
                    break;
                case IMessage.WARNING:
                    log.warn message.message, message.thrown
                    break;
                case IMessage.INFO:
                    log.info message.message, message.thrown
                    break;
                case IMessage.DEBUG:
                    log.debug message.message, message.thrown
                    break;
            }
        }
    }
}

//afterEvaluate ({
//    android.getApplicationVariants().all {
//        variant ->
//            String varientName = variant.name
//            String capitalizeName = varientName.capitalize()
//            Task dexTask = project.getTasks().findByName("dexBuilderDebug" + capitalizeName)
//
//            dexTask.doFirst {
//                FileCollection files = dexTask.getInputs().getFiles()
//                for (File file : files) {
//                    String filePath = file.getAbsolutePath()
//                    if (filePath.endsWith(".jar"))
//                        progressJar(file)
//                    else if (filePath.endsWith(".class"))
//                        progressClass(variant.getDirName(), file)
//                }
//            }
//    }
//})

static void progressJar(File file) {
    try {
        File bakJar = new File(file.getParent(), file.getName() + ".bak")
        JarOutputStream jos = new JarOutputStream(new FileOutputStream(bakJar))
        JarFile jarFile = new JarFile(file)
        Enumeration<JarEntry> entries = jarFile.entries()
        while (entries.hasMoreElements()) {
            JarEntry entry = entries.nextElement()
            jos.putNextEntry(new JarEntry(entry.getName()))
            InputStream is = jarFile.getInputStream(entry)
            String className = entry.getName()
            if (className.endsWith(".class") && !className.startsWith("com/example/designmode/MyApplication")
                    && !isAndroidClass(className) && className) {
                byte[] byteCode = referHack(is)
                jos.write(byteCode)
            } else {jos.write(IOUtils.toByteArray(is))}
            jos.closeEntry();
        }
        jos.close()
        jarFile.close()
        file.delete()
        bakJar.renameTo(file)
    } catch (IOException e) {e.printStackTrace()}
}

static void progressClass(String dirName, File file) {
    String filePath = file.getAbsolutePath()
    String className = filePath.split(dirName[1].substring(1))
    if (className.startsWith("com/example/designmode/MyApplication") || isAndroidClass(className))
        return
    try {
        FileInputStream fis = new FileInputStream(filePath)
        byte[] byteCode = referHack(fis)
        fis.close()
        FileOutputStream fos = new FileOutputStream(filePath)
        fos.write(byteCode)
        fos.close()
    } catch (IOException e) {e.printStackTrace()}
}

static boolean isAndroidClass(String filePath) {
    return filePath.startsWith("android") || filePath.startsWith("androidx")
}

static byte[] referHack(InputStream is) throws IOException{
    ClassReader cr = new ClassReader(is)
    ClassWriter cw = new ClassWriter(cr, 0)
    ClassVisitor cv = new ClassVisitor(Opcodes.ASM5, cw) {
        @Override
        MethodVisitor visitMethod(int access, String name, String descriptor, String signature, String[] exceptions) {
            MethodVisitor mv =  super.visitMethod(access, name, descriptor, signature, exceptions)
            mv = new MethodVisitor() {
                @Override
                void visitInsn(int opcode) {
                    if ("<init>".equals(name) && opcode == Opcodes.RETURN)
                        super.visitInsn(Type.getType("Lcom/example/designmode/blocklog/ExpectionCrashHandler;"))
                    super.visitInsn(opcode)
                }
            }
        }
    }
    cr.accept(cv, 0)
    return cw.toByteArray()
}